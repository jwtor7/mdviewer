<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>mdviewer v2.6.4 Prototype</title>
    <script src="./lib/react.development.js"></script>
    <script src="./lib/react-dom.development.js"></script>
    <script src="./lib/babel.min.js"></script>
    <script src="./lib/tailwindcss.js"></script>

    <!-- Import the ACTUAL app styles -->
    <link rel="stylesheet" href="../src/styles/syntax-highlighting.css">
    <link rel="stylesheet" href="../src/index.css">

    <style>
        /* Overrides for prototype environment */
        body {
            background-color: var(--bg-color);
            color: var(--text-color);
            overflow: hidden;
            /* App handles scrolling */
        }

        /* Fix for tailwind conflict with app styles */
        .prose {
            max-width: none;
        }

        /* Ensure full height */
        #root,
        .app-container {
            height: 100vh;
        }
    </style>
</head>

<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        // Mock Tokenizer to simulate Prism output for the prototype
        const mockPrismTokenize = (code, lang) => {
            if (lang !== 'javascript' && lang !== 'typescript' && lang !== 'js' && lang !== 'ts') {
                return code;
            }

            let html = code
                .replace(/&/g, "&amp;")
                .replace(/</g, "&lt;")
                .replace(/>/g, "&gt;")
                .replace(/"(.*?)"/g, '<span class="token string">"$1"</span>')
                .replace(/'(.*?)'/g, "<span class='token string'>'$1'</span>")
                .replace(/\b(const|let|var|function|return|if|else|for|while|import|from|export|default|class|interface)\b/g, '<span class="token keyword">$1</span>')
                .replace(/\b(true|false|null|undefined)\b/g, '<span class="token boolean">$1</span>')
                .replace(/\b(\d+)\b/g, '<span class="token number">$1</span>')
                .replace(/\/\/.*$/gm, '<span class="token comment">$&</span>')
                .replace(/\b(console|window|document|React|ReactDOM)\b/g, '<span class="token class-name">$1</span>')
                .replace(/(\w+)(?=\()/g, '<span class="token function">$1</span>');

            return html;
        };

        const MarkdownPreview = ({ content, theme }) => {
            const renderMarkdown = () => {
                const lines = content.split('\n');
                let inCodeBlock = false;
                let codeLang = '';
                let codeBuffer = [];
                let html = '';

                for (let i = 0; i < lines.length; i++) {
                    const line = lines[i];

                    if (line.trim().startsWith('```')) {
                        if (inCodeBlock) {
                            const code = codeBuffer.join('\n');
                            const highlighted = mockPrismTokenize(code, codeLang);
                            html += `<div class="mb-4 rounded overflow-hidden">
                                <pre class="language-${codeLang}"><code class="language-${codeLang}">${highlighted}</code></pre>
                            </div>`;
                            inCodeBlock = false;
                            codeBuffer = [];
                        } else {
                            inCodeBlock = true;
                            codeLang = line.trim().substring(3) || 'text';
                        }
                    } else if (inCodeBlock) {
                        codeBuffer.push(line);
                    } else {
                        if (line.startsWith('# ')) html += `<h1>${line.substring(2)}</h1>`;
                        else if (line.startsWith('## ')) html += `<h2>${line.substring(3)}</h2>`;
                        else if (line.startsWith('### ')) html += `<h3>${line.substring(4)}</h3>`;
                        else if (line.trim() === '') html += '<br/>';
                        else html += `<p>${line}</p>`;
                    }
                }
                return html;
            };

            return (
                <div className="markdown-preview" dangerouslySetInnerHTML={{ __html: renderMarkdown() }} />
            );
        };

        // Find & Replace Component
        const FindReplace = ({ onClose, onFind, onReplace, onReplaceAll }) => {
            const [findText, setFindText] = useState('');
            const [replaceText, setReplaceText] = useState('');

            return (
                <div className="find-replace-panel" style={{ top: '60px', right: '20px' }}>
                    <div className="find-replace-header">
                        <span className="find-replace-title">Find & Replace</span>
                        <button className="find-replace-close" onClick={onClose}>√ó</button>
                    </div>
                    <div className="find-replace-content">
                        <div className="find-replace-row">
                            <input
                                className="find-replace-input"
                                placeholder="Find"
                                value={findText}
                                onChange={(e) => setFindText(e.target.value)}
                                autoFocus
                            />
                            <div className="find-replace-buttons">
                                <button className="find-replace-btn" onClick={() => onFind(findText)}>Find</button>
                            </div>
                        </div>
                        <div className="find-replace-row">
                            <input
                                className="find-replace-input"
                                placeholder="Replace"
                                value={replaceText}
                                onChange={(e) => setReplaceText(e.target.value)}
                            />
                            <div className="find-replace-buttons">
                                <button className="find-replace-btn" onClick={() => onReplace(findText, replaceText)}>Replace</button>
                                <button className="find-replace-btn" onClick={() => onReplaceAll(findText, replaceText)}>All</button>
                            </div>
                        </div>
                    </div>
                </div>
            );
        };

        function App() {
            const [content, setContent] = useState(`# mdviewer v2.6.4 Demo

This prototype demonstrates **Bold**, *Italic*, and **Find & Replace**.

## Code Example

\`\`\`typescript
import React from 'react';

function App() {
  const greeting = "Hello, World!";
  return <div>{greeting}</div>;
}
\`\`\`
`);
            const [viewMode, setViewMode] = useState('SPLIT');
            const [theme, setTheme] = useState('dark');
            const [showFindReplace, setShowFindReplace] = useState(false);
            const textareaRef = useRef(null);

            useEffect(() => {
                document.documentElement.setAttribute('data-theme', theme);
            }, [theme]);

            const cycleTheme = () => {
                const themes = ['system', 'light', 'dark', 'solarized-light', 'solarized-dark'];
                const currentIndex = themes.indexOf(theme);
                const nextIndex = (currentIndex + 1) % themes.length;
                setTheme(themes[nextIndex]);
            };

            const handleFormat = (type) => {
                const textarea = textareaRef.current;
                if (!textarea) return;

                const start = textarea.selectionStart;
                const end = textarea.selectionEnd;
                const selectedText = content.substring(start, end);
                let newText = '';
                let newCursorPos = end;

                if (type === 'bold') {
                    newText = `**${selectedText}**`;
                    newCursorPos += 4;
                } else if (type === 'italic') {
                    newText = `*${selectedText}*`;
                    newCursorPos += 2;
                }

                const updatedContent = content.substring(0, start) + newText + content.substring(end);
                setContent(updatedContent);

                // Restore focus and cursor
                setTimeout(() => {
                    textarea.focus();
                    textarea.setSelectionRange(start, start + newText.length);
                }, 0);
            };

            const handleFind = (text) => {
                if (!text) return;
                const textarea = textareaRef.current;
                if (!textarea) return;

                const index = content.indexOf(text, textarea.selectionEnd);
                if (index !== -1) {
                    textarea.focus();
                    textarea.setSelectionRange(index, index + text.length);
                } else {
                    // Loop around
                    const wrappedIndex = content.indexOf(text);
                    if (wrappedIndex !== -1) {
                        textarea.focus();
                        textarea.setSelectionRange(wrappedIndex, wrappedIndex + text.length);
                    } else {
                        alert('Not found');
                    }
                }
            };

            const handleReplace = (findText, replaceText) => {
                const textarea = textareaRef.current;
                if (!textarea) return;

                const start = textarea.selectionStart;
                const end = textarea.selectionEnd;
                const selectedText = content.substring(start, end);

                if (selectedText === findText) {
                    const newContent = content.substring(0, start) + replaceText + content.substring(end);
                    setContent(newContent);
                    setTimeout(() => {
                        textarea.focus();
                        textarea.setSelectionRange(start, start + replaceText.length);
                    }, 0);
                } else {
                    handleFind(findText);
                }
            };

            const handleReplaceAll = (findText, replaceText) => {
                if (!findText) return;
                const newContent = content.split(findText).join(replaceText);
                setContent(newContent);
            };

            return (
                <div className="app-container">
                    <div className="toolbar">
                        <div className="toolbar-group">
                            <div className="toolbar-title">mdviewer v2.6.4 (Prototype)</div>
                        </div>

                        <div className="toolbar-group">
                            <button className="icon-btn" onClick={() => handleFormat('bold')} title="Bold"><b>B</b></button>
                            <button className="icon-btn" onClick={() => handleFormat('italic')} title="Italic"><i>I</i></button>
                            <div className="toolbar-divider"></div>
                            <button className="icon-btn" onClick={() => setShowFindReplace(!showFindReplace)} title="Find & Replace">üîç</button>
                            <button className="icon-btn" onClick={cycleTheme} title="Toggle Theme">üé® {theme}</button>

                            <div className="toggle-container">
                                <button className={`toggle-btn ${viewMode === 'RENDERED' ? 'active' : ''}`} onClick={() => setViewMode('RENDERED')}>Rendered</button>
                                <button className={`toggle-btn ${viewMode === 'RAW' ? 'active' : ''}`} onClick={() => setViewMode('RAW')}>Raw</button>
                                <button className={`toggle-btn ${viewMode === 'SPLIT' ? 'active' : ''}`} onClick={() => setViewMode('SPLIT')}>Split</button>
                            </div>
                        </div>
                    </div>

                    <div className="content-area">
                        {showFindReplace && (
                            <FindReplace
                                onClose={() => setShowFindReplace(false)}
                                onFind={handleFind}
                                onReplace={handleReplace}
                                onReplaceAll={handleReplaceAll}
                            />
                        )}

                        {viewMode === 'RENDERED' && <MarkdownPreview content={content} theme={theme} />}

                        {viewMode === 'RAW' && (
                            <textarea
                                ref={textareaRef}
                                className="code-editor"
                                value={content}
                                onChange={(e) => setContent(e.target.value)}
                            />
                        )}

                        {viewMode === 'SPLIT' && (
                            <div className="split-view">
                                <div className="split-pane split-pane-left" style={{ width: '50%' }}>
                                    <textarea
                                        ref={textareaRef}
                                        className="code-editor"
                                        value={content}
                                        onChange={(e) => setContent(e.target.value)}
                                    />
                                </div>
                                <div className="split-divider"></div>
                                <div className="split-pane split-pane-right" style={{ width: '50%' }}>
                                    <MarkdownPreview content={content} theme={theme} />
                                </div>
                            </div>
                        )}
                    </div>

                    <div className="status-bar">
                        <div className="status-item">Words: {content.split(/\s+/).filter(w => w.length > 0).length}</div>
                        <div className="status-version">v2.6.4-proto</div>
                    </div>
                </div>
            );
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>

</html>